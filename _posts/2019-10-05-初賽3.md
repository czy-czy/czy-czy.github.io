---
layout: post
title: 對於莫隊的復習
date: 2019-10-05
categories: blog
tags: []
description: 
---

今天做的題用到了莫隊，我們不妨來總結一下。


<h1 id="莫队算法是个啥">1、莫队算法是个啥</h1>
<h4 id="来历">来历：</h4>
<p>前面已经介绍过了（逃</p>
<p>有兴趣的同学可以看一下<a href="https://www.zhihu.com/people/mythly/activities">莫涛大神的知乎</a></p>
<h2 id="然而这个算法到底是用来搞什么操作的呢我们先看个例题">然而这个算法到底是用来搞什么操作的呢？我们先看个例题：</h2>
<h3 id="luogu-p1972-sdoi2009hh的项链"><a href="https://www.luogu.org/problemnew/show/P1972">Luogu P1972 [SDOI2009]HH的项链</a></h3>
<h4 id="题目描述">题目描述</h4>
<p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h4 id="输入输出格式">输入输出格式</h4>
<h4 id="输入格式">输入格式：</h4>
<p>第一行：一个整数N，表示项链的长度。</p>
<p>第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。</p>
<p>第三行：一个整数M，表示HH 询问的个数。</p>
<p>接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。</p>
<h4 id="输出格式">输出格式：</h4>
<p>M 行，每行一个整数，依次表示询问对应的答案。</p>
<h4 id="输入输出样例">输入输出样例</h4>
<h4 id="输入样例1">输入样例#1：</h4>
<pre><code>6
1 2 3 4 3 5
3
1 2
3 5
2 6</code></pre>
<h4 id="输出样例1">输出样例#1：</h4>
<pre><code>2
2
4</code></pre>
<h4 id="说明">说明</h4>
<h4 id="数据范围">数据范围：</h4>
<p>对于100%的数据，N &lt;= 500000，M &lt;= 500000。</p>
<hr />
<p>题意简明易懂：给你一个长度不大于<span class="math inline">\(n≤5×10^5\)</span>的序列，其中数值都小于等于<span class="math inline">\(10^6\)</span>，有<span class="math inline">\(m≤5×10^5\)</span>次询问，每次询问区间<span class="math inline">\([l,r]\)</span>中数值个数（也就是去重后数字的个数）。</p>
<h3 id="不过这个例题卡了莫队所以请左转数据弱化版sp3267-dquery---d-query">不过这个例题卡了莫队，所以请左转数据弱化版：<a href="https://www.luogu.org/problemnew/show/SP3267">SP3267 DQUERY - D-query</a></h3>
<p>题目到手，我们开始分析本题的算法。这题最简单做法无非暴力——用一个<span class="math inline">\(cnt\)</span>数组记录每个数值出现的次数，再暴力枚举<span class="math inline">\(l\)</span>到<span class="math inline">\(r\)</span>统计次数，最后再扫一遍cnt数组，统计<span class="math inline">\(cnt\)</span>不为零的数值个数，输出答案即可。设最大数值为<span class="math inline">\(s\)</span>，那么这样做的复杂度为<span class="math inline">\(O(m(n+s))∽O(n^2)\)</span>，对于本题实在跑不起。</p>
<h3 id="我们可以尝试优化一下">我们可以尝试优化一下：</h3>
<h4 id="优化1每次枚举到一个数值num增加出现次数时判断一下cnt_num是否为0如果为0则这个数值之前没有出现过现在出现了数值数当然要1反之在从区间中删除num后也判断一下cnt_num是否为0如果为0数值总数-1这样我们优化掉了一个oms但还是跑不起">优化1：每次枚举到一个数值<span class="math inline">\(num\)</span>，增加出现次数时判断一下<span class="math inline">\(cnt_{num}\)</span>是否为0，如果为0，则这个数值之前没有出现过，现在出现了，数值数当然要+1。反之在从区间中删除<span class="math inline">\(num\)</span>后也判断一下<span class="math inline">\(cnt_{num}\)</span>是否为0，如果为0数值总数-1。这样我们优化掉了一个<span class="math inline">\(O(ms)\)</span>，但还是跑不起。</h4>
<h4 id="优化2我们弄两个指针-l-r-每次询问不直接枚举而是移动-l-r-指针到询问的区间直到lr与询问区间重合在统计答案时我们也只在两个指针处加减cnt然后我们就可以用优化1中的方法快速地统计答案啦qwq">优化2：我们弄两个指针 <span class="math inline">\(l\)</span> 、<span class="math inline">\(r\)</span> ，每次询问不直接枚举，而是移动 <span class="math inline">\(l\)</span> 、<span class="math inline">\(r\)</span> 指针到询问的区间，直到<span class="math inline">\([l,r]\)</span>与询问区间重合。在统计答案时，我们也只在两个指针处加减<span class="math inline">\(cnt\)</span>，然后我们就可以用优化1中的方法快速地统计答案啦<span class="math inline">\(qwq\)</span>！</h4>
<hr />
<p>优化2具体步骤如下：</p>
<p>假设这个序列是这样子的：（其中<span class="math inline">\(Q1\)</span>、<span class="math inline">\(Q2\)</span>是询问区间）</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214111957440-289670786.jpg" /></p>
<p>我们初始化<span class="math inline">\(l=1\)</span>、<span class="math inline">\(r=0\)</span>（如果<span class="math inline">\(l=0\)</span>，那么我们还需要删除一个数值<span class="math inline">\(0\)</span>，使其出现次数变成-1，导致一些奇奇怪怪错误），如下图（由于画图软件中<span class="math inline">\(l\)</span>和<span class="math inline">\(1\)</span>看不出区别，我只好在图中使用<span class="math inline">\(L\)</span>和<span class="math inline">\(R\)</span>来表示qwq）：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214112312924-142905583.jpg" /></p>
<p>我们发现 <span class="math inline">\(l\)</span> 已经是第一个查询区间的左端点，无需移动。现在我们将 <span class="math inline">\(r\)</span> 右移一位，发现新数值1：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132130120-1554450961.jpg" /></p>
<p><span class="math inline">\(r\)</span> 继续右移，发现新数值2：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132211435-482551090.jpg" /></p>
<p>继续右移，发现新数值4：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132245702-439750869.jpg" /></p>
<p>当 <span class="math inline">\(r\)</span> 再次右移时，发现此时的新位置中的数值2出现过，数值总数不增：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132410275-1972965271.jpg" /></p>
<p>接下来是两个7，由于7没出现过，所以总数+1：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132450055-1521044095.jpg" /></p>
<p>继续右移发现3：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132530925-1512284326.jpg" /></p>
<p>继续右移，但接下来的两个数值都出现过，总数不增。</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132620562-1439006141.jpg" /></p>
<h3 id="至此q1区间所有数值统计完成结果为5">至此，<span class="math inline">\(Q1\)</span>区间所有数值统计完成，结果为5。</h3>
<h3 id="现在我们又看一下q2区间的情况">现在我们又看一下<span class="math inline">\(Q2\)</span>区间的情况：</h3>
<p>首先我们发现， <span class="math inline">\(l\)</span> 指针在<span class="math inline">\(Q2\)</span>区间左端点的左边，我们需要将它右移，同时删除原位置的统计信息。</p>
<p>将<span class="math inline">\(l\)</span>右移一位到位置2，删除位置1处的数值1。但由于操作后的区间中仍然有数值1存在，所以总数不减。</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214134652168-9341337.jpg" /></p>
<p>接下来的两位也是如此，直接删掉即可，总数不减。</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214134950911-245687742.jpg" /></p>
<p>当 <span class="math inline">\(l\)</span> 指针继续右移时，发现一个问题：原位置上的数值是2，但是删除这个2后，此时的区间<span class="math inline">\([l,r]\)</span>中再也没有2了（回顾之前的内容，这种情况就是删除后<span class="math inline">\(cnt_2 = 0\)</span>），那么总数就要-1，因为有一个数值已经不在该区间内出现了，而本题需要统计的就是区间内的数值个数。此步骤如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214141945700-1377126698.jpg" /></p>
<p>再右移一位，发现无需减总数，而且<span class="math inline">\(l\)</span>已经移到了<span class="math inline">\(Q2\)</span>区间的左端点，无需继续移下去（如下图）。当然 <span class="math inline">\(r\)</span> 还是要移动的，只不过没图了，我相信大家应该知道做法的<span class="math inline">\(qwq\)</span>。</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214142409184-977743178.jpg" /></p>
<p><span class="math inline">\(r\)</span>的最后位置：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214142435118-121917103.jpg" /></p>
<h4 id="至于删除操作也是一样的做法只不过要先删除当前位置的数值才能移动指针">至于删除操作，也是一样的做法，只不过要先删除当前位置的数值，才能移动指针。</h4>
<p>有了以上的内容，这段代码就可以很容易写出啦qwq：</p>
<pre class="cpp"><code>int aa[maxn], cnt[maxn], l = 1, r = 0, now = 0; //每个位置的数值、每个数值的计数器、左指针、右指针、当前统计结果（总数）
void add(int pos) {//添加一个数
    if(!cnt[aa[pos]]) ++now;//在区间中新出现，总数要+1
    ++cnt[aa[pos]];
}
void del(int pos) {//删除一个数
    --cnt[aa[pos]];
    if(!cnt[aa[pos]]) --now;//在区间中不再出现，总数要-1
}
void work() {//优化2主过程
    for(int i = 1; i &lt;= q; ++i) {//对于每次询问
        int ql, qr;
        scanf(&quot;%d%d&quot;, &amp;ql, &amp;qr);//输入询问的区间
        while(l &lt; ql) del(l++);//如左指针在查询区间左方，左指针向右移直到与查询区间左端点重合
        while(l &gt; ql) add(--l);//如左指针在查询区间左端点右方，左指针左移
        while(r &lt; qr) add(++r);//右指针在查询区间右端点左方，右指针右移
        while(r &gt; qr) del(r--);//否则左移
        printf(&quot;%d\n&quot;, now);//输出统计结果
    }
}</code></pre>
<h3 id="优化2完结撒花ヽノqwq">优化2完结撒花✿✿ヽ(°▽°)ノ✿<span class="math inline">\(qwq\)</span></h3>
<hr />
<p>诶等等，什么叫做“优化2完结撒花”？？！</p>
<p>难道这不就是莫队吗？？！</p>
<p>我会很严肃的告诉你：这还不是莫队，但是看到这里，你已经把莫队的基础打好了。还请继续看下去：</p>
<hr />
<p>刚刚的优化2，在普通的情况下表现很好，但是如果区间是这样：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214145508773-749403260.jpg" /></p>
<p>优化2基本上就萎了<span class="math inline">\(qwq\)</span>。此时<span class="math inline">\(l\)</span>、<span class="math inline">\(r\)</span>指针在整个序列中移来移去，从头到尾，又从尾到头。我们发现左右指针最坏情况下均移动了<span class="math inline">\(O(nm)\)</span>次，<span class="math inline">\(O(1)\)</span>更新答案，总时间复杂度仍然是<span class="math inline">\(O(nm)\)</span>，在最坏情况下跑得比慢的一批的优化1还慢。尽管如此，我们还是可以继续优化。</p>
<h4 id="继续优化怎么优化">继续优化？怎么优化？</h4>
<p>我们可以考虑把所有查询区间按左端点排序，从而使左指针最多移动<span class="math inline">\(O(n)\)</span>次。但这样的话右端点又是无序的，右指针又让整体复杂度打回原形。看上去，这个复杂度已经不能再优化了。在这个时候，<strong>莫队</strong>算法的出现，给无数OIer带来了光明（雾）。</p>
<h3 id="至此你可以把莫队算法理解为一种暴力优雅而不失复杂度的暴力只不过它的剪枝极为巧妙达到了理想的效果">至此，你可以把莫队算法理解为一种暴力，优雅<del>而不失复杂度</del>的暴力，只不过它的剪枝极为巧妙，达到了理想的效果。</h3>
<hr />
<h1 id="莫队算法的基础实现">2、莫队算法的基础实现</h1>
<h2 id="预处理">1、预处理</h2>
<p>莫队算法优化的核心是分块和排序。我们将大小为<span class="math inline">\(n\)</span>的序列分为<span class="math inline">\(\sqrt{n}\)</span>个块，从<span class="math inline">\(1\)</span>到<span class="math inline">\(\sqrt{n}\)</span>编号，然后根据这个对查询区间进行排序。一种方法是把查询区间按照<strong>左端点所在块的序号</strong>排个序，如果左端点所在块相同，再按<strong>右端点</strong>排序。排完序后我们再进行左右指针跳来跳去的操作，虽然看似没多大用，但带来的优化实际上极大。</p>
<hr />
<h3 id="那么这样做的实际复杂度是多少呢下面瞎胡乱搞证明它的复杂度是onsqrtn">那么这样做的实际复杂度是多少呢？下面<del>瞎胡乱搞</del>证明它的复杂度是<span class="math inline">\(O(n\sqrt{n})\)</span>：</h3>
<h4 id="区间排序">0.区间排序</h4>
<p>建个结构体，用<code>sort</code>跑一遍即可。平均复杂度<span class="math inline">\(O(n\log n)\)</span>。</p>
<h4 id="左指针的移动">1.左指针的移动</h4>
<p>设每个块 <span class="math inline">\(i\)</span> 中分布有 <span class="math inline">\(x_i\)</span>个左端点，由于莫队的添加、删除操作复杂度为<span class="math inline">\(O(1)\)</span>，那么处理块<span class="math inline">\(i\)</span>的最坏时间复杂度是<span class="math inline">\(O(x_i\sqrt{n})\)</span>，指针跨越整块的时间复杂度为O(\sqrt{n})，最坏需要跨越<span class="math inline">\(n\)</span>次；总复杂度<span class="math inline">\(O(\sum x_i \sqrt{n}+n\sqrt{n})=O(n\sqrt{n})\)</span>。</p>
<h4 id="右指针的移动">2.右指针的移动</h4>
<p>设每个块 <span class="math inline">\(i\)</span> 中分布有 <span class="math inline">\(x_i\)</span>个左端点，由于左端点同块的区间右端点有序，那么对于这<span class="math inline">\(x_i\)</span>个区间，右端点最坏只需总共<span class="math inline">\(O(n)\)</span>的时间跳（最坏需跳完整个序列），总共<span class="math inline">\(\sqrt{n}\)</span>个块，总复杂度<span class="math inline">\(O(n\sqrt{n})\)</span>；</p>
<h3 id="至此可得出莫队算法的总时间复杂度为onsqrtn-onsqrtn-onlog-n-onsqrtn">至此可得出，莫队算法的总时间复杂度为<span class="math inline">\(O(n\sqrt{n}) + O(n\sqrt{n}) + O(n\log n) = O(n\sqrt{n})\)</span>。</h3>
<hr />
<p>可见，经过一番看似鸡肋的排序之后，这个算法的复杂度猛降了一个根号之多，对于一些不需要写大常数莫队而数据范围巨大的题目来说（如例题），整整一个根号的提升意味着运行时间质的飞跃。</p>
<p>不过经过排序打乱原序之后，这个算法就变成了典型的离线算法，而且这种算法不支持修改。如果遇到强制在线的题目，还要另寻他法。</p>
<hr />
<h3 id="参考代码">参考代码：</h3>
<p>查询区间结构体的排序函数：</p>
<pre class="cpp"><code>int cmp(query a, query b) {
    return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l];
}</code></pre>
<hr />
<h2 id="定策略">2、定策略</h2>
<p>虽说莫队实质是优化后的暴力，但有时候，有些用暴力枚举很容易处理的数据用莫队并不容易处理（只能在左右指针处更新），这时候就要我们定好一个更新策略。<br />
一般来说，我们只要找到指针移动一位以后，统计数据与当前数据的差值，找出规律（可以用数学方法或打表），然后每次移动时用这个规律更新就行啦qwq。至于例题……在后面会有哒qwq！</p>
<h2 id="码代码与查错">3、码代码与查错</h2>
<p>莫队代码不长（或者说是<strong>很短</strong>），但很容易写错一些细节。比如自加自减运算符的优先级问题、排序关键字问题、分块大小与sqrt精度问题、还有某些题目中用到的离散化的锅。所以每次码完莫队都别先测样例（甚至可以先不编译），先静态查错一阵，真的可以帮助你大大减少错误的发生。</p>
<h1 id="后面两点都特别简单但是没有特定的模式其重要性不容小觑">后面两点都特别简单但是没有特定的模式，其重要性不容小觑。</h1>
<hr />
<h1 id="重点莫队的玄学卡常技巧">3、（重点）莫队的<del>玄学</del>卡常技巧</h1>
<h2 id="warning以下内容可能引出大贤者模式请谨慎思考">WARNING：以下内容可能引出大贤者模式，请谨慎思考。</h2>
<h2 id="pragma-gcc-optimize2">1、#pragma GCC optimize(2)</h2>
<p><del>可以用实践证明，</del>开了O2的莫队简直跑得飞快，连<span class="math inline">\(1e6\)</span>都能无压力跑过，甚至可以比不开O2的版本快上4~5倍乃至更多。然而部分OI比赛中O2是禁止的，如果不禁O2的话，那还是开着吧qwq</p>
<p><del>实在不行，就optimize(3)（逃</del></p>
<h2 id="莫队玄学奇偶性排序">2、莫队玄学奇偶性排序</h2>
<h4 id="这个是最玄学的无力吐槽">这个是最玄学的……无力吐槽</h4>
<p>这个和莫队的主算法有异曲同工之妙……看起来卵用都没有，实际上可以帮你每个点平均优化200ms（可怕）</p>
<p>主要操作：把查询区间的排序函数</p>
<pre class="cpp"><code>int cmp(query a, query b) {
    return belong[a.l] == belong[b.l] ? a.r &lt; b.r : belong[a.l] &lt; belong[b.l];
}</code></pre>
<p>二话不说，直接删掉，换成</p>
<pre class="cpp"><code>int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);
}</code></pre>
<p>也就是说，对于左端点在同一奇数块的区间，右端点按升序排列，反之降序。这个东西也是看着没用，但实际效果显著。</p>
<p>它的主要原理便是右指针跳完奇数块往回跳时在同一个方向能顺路把偶数块跳完，然后跳完这个偶数块又能顺带把下一个奇数块跳完。理论上主算法运行时间减半，实际情况有所偏差。<del>（不过能优化得很爽就对了）</del></p>
<h3 id="移动指针的常数压缩">3、移动指针的常数压缩</h3>
<p>我们可以根据运算优先级的知识，把这个：</p>
<pre class="cpp"><code>void add(int pos) {
    if(!cnt[aa[pos]]) ++now;
    ++cnt[aa[pos]];
}
void del(int pos) {
    --cnt[aa[pos]];
    if(!cnt[aa[pos]]) --now;
}</code></pre>
<p>和这个：</p>
<pre class="cpp"><code>while(l &lt; ql) del(l++);
while(l &gt; ql) add(--l);
while(r &lt; qr) add(++r);
while(r &gt; qr) del(r--);</code></pre>
<p>硬生生压缩成这个：</p>
<pre class="cpp"><code>while(l &lt; ql) now -= !--cnt[aa[l++]];
while(l &gt; ql) now += !cnt[aa[--l]]++;
while(r &lt; qr) now += !cnt[aa[++r]]++;
while(r &gt; qr) now -= !--cnt[aa[r--]];</code></pre>
<p>能优化将近200ms<del>（怎么又是这个数字）</del></p>
<p>而且这个优化看上去满满的不好搞，但实际上很有用。不过用它来优化千万要建立在熟练的基础上，不然会大大增强调试难度，不如不用。</p>
<h3 id="手写快读快输">4、手写快读、快输</h3>
<p>大多数莫队题的输入输出量还是很大的……I/O优化与否，运行时间差异也很大。而且值得注意的是莫队经典题中基本没有输入输出负数的情况，不考虑负数又能优化一点小小的常数。</p>
<h4 id="卡常部分到此结束撒花ヽノ脑补欢呼音效">卡常部分到此结束，撒花✿✿ヽ(°▽°)ノ✿<del>（脑补欢呼音效）</del></h4>
<hr />
<h2 id="讲到现在例题的代码已经不难写出下面给出参考代码">讲到现在，例题的代码已经不难写出。下面给出参考代码：</h2>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;

#define maxn 1010000
#define maxb 1010
int aa[maxn], cnt[maxn], belong[maxn];
int n, m, size, bnum, now, ans[maxn];
struct query {
    int l, r, id;
} q[maxn];

int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);
}
#define isdigit(x) ((x) &gt;= &#39;0&#39; &amp;&amp; (x) &lt;= &#39;9&#39;)
int read() {
    int res = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar();
    return res;
}
void printi(int x) {
    if(x / 10) printi(x / 10);
    putchar(x % 10 + &#39;0&#39;);
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    size = sqrt(n);
    bnum = ceil((double)n / size);
    for(int i = 1; i &lt;= bnum; ++i) 
        for(int j = (i - 1) * size + 1; j &lt;= i * size; ++j) {
            belong[j] = i;
        }
    for(int i = 1; i &lt;= n; ++i) aa[i] = read(); 
    m = read();
    for(int i = 1; i &lt;= m; ++i) {
        q[i].l = read(), q[i].r = read();
        q[i].id = i;
    }
    sort(q + 1, q + m + 1, cmp);
    int l = 1, r = 0;
    for(int i = 1; i &lt;= m; ++i) {
        int ql = q[i].l, qr = q[i].r;
        while(l &lt; ql) now -= !--cnt[aa[l++]];
        while(l &gt; ql) now += !cnt[aa[--l]]++;
        while(r &lt; qr) now += !cnt[aa[++r]]++;
        while(r &gt; qr) now -= !--cnt[aa[r--]];
        ans[q[i].id] = now;
    }
    for(int i = 1; i &lt;= m; ++i) printi(ans[i]), putchar(&#39;\n&#39;);
    return 0;
}</code></pre>
<hr />
<h1 id="莫队算法的扩展带修改的莫队">4、莫队算法的扩展——带修改的莫队</h1>
<h3 id="抛出个例题luogu-p1903-国家集训队数颜色-维护队列">抛出个例题：<a href="https://www.luogu.org/problemnew/show/P1903">Luogu P1903 [国家集训队]数颜色 / 维护队列</a></h3>
<h4 id="题目描述-1">题目描述</h4>
<p>墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：</p>
<p>1、 <span class="math inline">\(Q\)</span> <span class="math inline">\(L\)</span> <span class="math inline">\(R\)</span>代表询问你从第<span class="math inline">\(L\)</span>支画笔到第<span class="math inline">\(R\)</span>支画笔中共有几种不同颜色的画笔。</p>
<p>2、 <span class="math inline">\(R\)</span> <span class="math inline">\(P\)</span> <span class="math inline">\(Col\)</span> 把第<span class="math inline">\(P\)</span>支画笔替换为颜色<span class="math inline">\(Col\)</span>。</p>
<p>为了满足墨墨的要求，你知道你需要干什么了吗？</p>
<h4 id="输入输出格式-1">输入输出格式</h4>
<h4 id="输入格式-1">输入格式：</h4>
<p>第1行两个整数<span class="math inline">\(N\)</span>，<span class="math inline">\(M\)</span>，分别代表初始画笔的数量以及墨墨会做的事情的个数。</p>
<p>第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。</p>
<p>第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。</p>
<h4 id="输出格式-1">输出格式：</h4>
<p>对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<h4 id="输入输出样例-1">输入输出样例</h4>
<p>输入样例#1：</p>
<pre><code>6 5
1 2 3 4 5 5
Q 1 4
Q 2 6
R 1 2
Q 1 4
Q 2 6</code></pre>
<h4 id="输出样例1-1">输出样例#1：</h4>
<pre><code>4
4
3
4</code></pre>
<hr />
<h4 id="说明-1">说明</h4>
<p>对于<span class="math inline">\(100%\)</span>的数据，<span class="math inline">\(N≤50000\)</span>，<span class="math inline">\(M≤50000\)</span>，所有的输入数据中出现的所有整数均大于等于1且不超过<span class="math inline">\(10^6\)</span>。</p>
<p>前面说过，莫队算法是离线算法，不支持修改，强制在线需要另寻他法。的确，遇到强制在线的题目莫队基本上萎了，但是对于某些允许离线的带修改区间查询来说，莫队还是能大展拳脚的。做法就是把莫队直接加上一维，变为带修莫队。</p>
<p>那么加上一维什么呢？具体怎么实现？我们的做法是把修改操作编号，称为&quot;时间戳&quot;，<strong>而查询操作的时间戳沿用之前最近的修改操作的时间戳</strong>。跑主算法时定义当前时间戳为 <span class="math inline">\(t\)</span> ，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</p>
<h4 id="通俗地讲就是再弄一指针在修改操作上跳来跳去如果当前修改多了就改回来改少了就改过去直到次数恰当为止">通俗地讲，就是再弄一指针，在修改操作上跳来跳去，如果当前修改多了就改回来，改少了就改过去，直到次数恰当为止。</h4>
<p>这样，我们当前区间的移动方向从四个（<span class="math inline">\([l-1,r]\)</span>、<span class="math inline">\([l+1,r]\)</span>、<span class="math inline">\([l,r-1]\)</span>、<span class="math inline">\([l,r+1]\)</span>）变成了六个（<span class="math inline">\([l-1,r,t]\)</span>、<span class="math inline">\([l+1,r,t]\)</span>、<span class="math inline">\([l,r-1,t]\)</span>、<span class="math inline">\([l,r+1,t]\)</span>、<span class="math inline">\([l,r,t-1]\)</span>、<span class="math inline">\([l,r,t+1]\)</span>），但是代码并没有增加多少，<del>还是很好背的（雾</del></p>
<h3 id="带修改莫队的排序">带修改莫队的排序：</h3>
<p>其实排序的主要方法还是跟普通莫队没两样，只不过是加了个关键字而已。</p>
<p>排序函数：</p>
<pre class="cpp"><code>int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.r] ^ belong[b.r]) ? belong[a.r] &lt; belong[b.r] : a.time &lt; b.time);
}</code></pre>
<p>但是实测有时排序写错还会快些。。。也许是评测机的锅吧。</p>
<h3 id="主算法中的修改操作">主算法中的修改操作</h3>
<p>修改操作其实也没啥值得注意的，就跟移<span class="math inline">\(l\)</span>、<span class="math inline">\(r\)</span>指针一样，加个对总数的特判就行了。</p>
<p>不过有个代码长度的小优化——移完 <span class="math inline">\(t\)</span>，做完一处修改后，有可能要改回来，所以我们还要把原值存好备用。但其实我们也可以不存，只要在修改后把修改操作的值和原值<code>swap</code>一下，那么改回来时也只要<code>swap</code>一下，<code>swap</code>两次相当于没搞，就改回来了<span class="math inline">\(qwq\)</span><del>（所以不还是存了嘛）</del></p>
<h3 id="分块大小和复杂度">分块大小和复杂度</h3>
<p>有的<span class="math inline">\(dalao\)</span>证明了当块的大小设<span class="math inline">\(\sqrt[3]{n^4t}\)</span>时理论复杂度达到最优，但是小蒟蒻我并不能推出来。不过可以证明，块大小取<span class="math inline">\(n^{\frac{2}{3}}\)</span>优于取<span class="math inline">\(\sqrt{n}\)</span>的情况，总体复杂度<span class="math inline">\(O(n^{\frac{5}{3}})\)</span>。而块大小取<span class="math inline">\(\sqrt{n}\)</span>时会退化成<span class="math inline">\(O(n^2)\)</span>，不建议使用。</p>
<h3 id="例题参考代码">例题参考代码：</h3>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 50500
#define maxc 1001000
int a[maxn], cnt[maxc], ans[maxn], belong[maxn];
struct query {
    int l, r, time, id;
} q[maxn];
struct modify {
    int pos, color, last;
} c[maxn];
int cntq, cntc, n, m, size, bnum;
int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.r] ^ belong[b.r]) ? belong[a.r] &lt; belong[b.r] : a.time &lt; b.time);
}
#define isdigit(x) ((x) &gt;= &#39;0&#39; &amp;&amp; (x) &lt;= &#39;9&#39;)
inline int read() {
    int res = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (c ^ 48), c = getchar();
    return res;
}
int main() {
    n = read(), m = read();
    size = pow(n, 2.0 / 3.0);
    bnum = ceil((double)n / size);
    for(int i = 1; i &lt;= bnum; ++i) 
        for(int j = (i - 1) * size + 1; j &lt;= i * size; ++j) belong[j] = i;
    for(int i = 1; i &lt;= n; ++i) 
        a[i] = read();
    for(int i = 1; i &lt;= m; ++i) {
        char opt[100];
        scanf(&quot;%s&quot;, opt);
        if(opt[0] == &#39;Q&#39;) {
            q[++cntq].l = read();
            q[cntq].r = read();
            q[cntq].time = cntc;
            q[cntq].id = cntq;
        }
        else if(opt[0] == &#39;R&#39;) {
            c[++cntc].pos = read();
            c[cntc].color = read();
        }
    }
    sort(q + 1, q + cntq + 1, cmp);
    int l = 1, r = 0, time = 0, now = 0;
    for(int i = 1; i &lt;= cntq; ++i) {
        int ql = q[i].l, qr = q[i].r, qt = q[i].time;
        while(l &lt; ql) now -= !--cnt[a[l++]];
        while(l &gt; ql) now += !cnt[a[--l]]++;
        while(r &lt; qr) now += !cnt[a[++r]]++;
        while(r &gt; qr) now -= !--cnt[a[r--]];
        while(time &lt; qt) {
            ++time;
            if(ql &lt;= c[time].pos &amp;&amp; c[time].pos &lt;= qr) now -= !--cnt[a[c[time].pos]] - !cnt[c[time].color]++;
            swap(a[c[time].pos], c[time].color);
        }
        while(time &gt; qt) {
            if(ql &lt;= c[time].pos &amp;&amp; c[time].pos &lt;= qr) now -= !--cnt[a[c[time].pos]] - !cnt[c[time].color]++;
            swap(a[c[time].pos], c[time].color);
            --time;
        }
        ans[q[i].id] = now;
    }
    for(int i = 1; i &lt;= cntq; ++i) 
        printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}</code></pre>
<hr />
<h1 id="莫队算法的扩展树上莫队">5、莫队算法的扩展——树上莫队</h1>
<p>前面我们所使用的莫队都是在一维的序列上进行，即使加了一维的时间轴，但是主题还是一维序列。那么树上统计问题能否用莫队来处理呢？答案是肯定的。</p>
<p>不要认为这个东西很高级，实际上它还是个序列。</p>
<h2 id="问题一子树统计">问题一：子树统计</h2>
<p>子树统计算是这里面最简单的了。在原树上跑一遍dfs序，然后发现一颗子树其实就是里面一段固定区间……</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181215111600163-2041279382.jpg" /></p>
<p>边跑dfs边弄子树对应的左右端点即可。</p>
<p>这里序列的长度=结点的个数。</p>
<p><del>实际上子树上的统计完全不需要莫队，传个标记就可以<span class="math inline">\(O(nlogn)\)</span>了</del></p>
<h2 id="问题二路径上的统计">问题二：路径上的统计</h2>
<h3 id="比如说这个题目sp10707-cot2---count-on-a-tree-ii">比如说这个题目：<a href="https://www.luogu.org/problemnew/show/SP10707">SP10707 COT2 - Count on a tree II</a></h3>
<h4 id="题目描述-2">题目描述</h4>
<p>给定一个n个节点的树，每个节点表示一个整数，问u到v的路径上有多少个不同的整数。</p>
<h4 id="输入格式-2">输入格式</h4>
<p>第一行有两个整数n和m（n＝40000，m＝100000）。</p>
<p>第二行有n个整数。第i个整数表示第i个节点表示的整数。</p>
<p>在接下来的n-1行中，每行包含两个整数u v，描述一条边（u，v）。</p>
<p>在接下来的m行中，每一行包含两个整数u v，询问u到v的路径上有多少个不同的整数。</p>
<h4 id="输出格式-2">输出格式</h4>
<p>对于每个询问，输出结果。</p>
<h4 id="输入输出样例-2">输入输出样例</h4>
<h4 id="输入样例1-1">输入样例#1：</h4>
<pre><code>8 2
105 2 9 3 8 5 7 7
1 2
1 3
1 4
3 5
3 6
3 7
4 8
2 5
7 8</code></pre>
<h4 id="输出样例1-2">输出样例#1：</h4>
<pre><code>4
4</code></pre>
<hr />
<p>这还不简单吗？dfs序一遍找区间……诶？区间呢qwq？</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181215112415809-340311464.jpg" /></p>
<p>参照上图，我可以负责地告诉你：普通dfs序是完全不行的（因为区间没有对应关系）。</p>
<p>但是还好我们有<strong>欧拉序</strong>，这是一种特殊的dfs序，可以解决很多普通dfs序解决不了的问题（就比如我们的树上莫队）。</p>
<h3 id="那欧拉序有什么特点呢怎么求它">那欧拉序有什么特点呢？怎么求它？</h3>
<p>还是那张图，我们对它求一遍欧拉序：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181215113053370-1887701954.jpg" /></p>
<p>这是个什么东西？！它怎么求得的暂且不谈（不过你也应该已经知道了），先看看它的性质：</p>
<p>我们看一看每个编号出现的次数——两次，无一例外。再看看它出现的两个位置有什么特点：</p>
<p>我们以编号<span class="math inline">\(2\)</span>为例，它出现在位置2和9，它中间的编号有<span class="math inline">\(4×2\)</span>、<span class="math inline">\(7×2\)</span>、<span class="math inline">\(5×2\)</span>。</p>
<p>再观察这棵树，诶，这些编号不都是<span class="math inline">\(2\)</span>的子树上的结点吗？？！</p>
<p>就这样，我们得出它的一条性质：<strong>树的欧拉序上两个相同编号（设为<span class="math inline">\(x\)</span>）之间的所有编号都出现两次，且都位于<span class="math inline">\(x\)</span>子树上。</strong>（前半句话其实可以由后半句话间接证明）</p>
<h4 id="它的求法也很简单在刚dfs到一个点时加入序列最后退出时也加入一遍现在知道这个性质的来源了吧qwq">它的求法也很简单，在刚dfs到一个点时加入序列，最后退出时也加入一遍。现在知道这个性质的来源了吧qwq</h4>
<p>那么为什么用欧拉序可以把路径搬到区间上呢？我们来看一下这张图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181215141104614-240155201.jpg" /></p>
<p>我们在欧拉序中找到路径<span class="math inline">\(1\rightarrow10\)</span>起点（1）终点（10）的位置。我们发现，我们完全可以在找到对应的区间（绿色部分），而由于其中有一些点出现了两次，这些出现了两次的点可以证明不在路径上（路径不会经过一个点两次，而如果只经过一次则不会出现两个相同的编号），所以出现了两次的点我们不予算入。</p>
<p>那我们尝试找一下<span class="math inline">\(2\rightarrow 6\)</span>对应的区间吧。唔，这还不简单吗，不就是2、4、7……3、6……嗯？1哪去了？1呢？^1可是他们的<span class="math inline">\(lca\)</span>啊！！看来这样单纯的找区间还是不行的，还有其他特殊方法。</p>
<p>具体做法：设每个点的编号<span class="math inline">\(a\)</span>首次出现的位置<span class="math inline">\(first[a]\)</span>，最后出现的位置为<span class="math inline">\(last[a]\)</span>，那么对于路径<span class="math inline">\(x\rightarrow y\)</span>，设<span class="math inline">\(first[x]&lt;=first[y]\)</span>（不满足则<code>swap</code>，这个操作的意义在于，如果<span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>在一条链上，则<span class="math inline">\(x\)</span>一定是<span class="math inline">\(y\)</span>的祖先或等于<span class="math inline">\(y\)</span>），如果<span class="math inline">\(lca(x,y)=x\)</span>，则直接把<span class="math inline">\([first[x],first[y]]\)</span>的区间扯过来用，反之使用<span class="math inline">\([last[x],first[y]]\)</span>区间（为什么不用<span class="math inline">\([first[x],first[y]]\)</span>？因为<span class="math inline">\((first[x],last[x])\)</span>不会在路径上，根据性质，里面的编号都会出现两次，考虑了等于没考虑），但这个区间内不包含<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的最近公共祖先，查询的时候加上即可。</p>
<p>注意，这里序列长度为<span class="math inline">\(2×n\)</span>，千万不要在这T了啊……qwq</p>
<hr />
<p>做完了这些，树上莫队的其他东西就和普通莫队差不多啦。值得注意的是，我们又可以像上文的带修莫队那样优化代码长度——由于无需考虑的点会出现两次，我们可以弄一个标记数组（标记结点是否被访问），没访问就加，访问过就删，每次操作把标记·异或个1，完美解决所有添加、删除、去双问题。</p>
<h3 id="例题参考代码-1">例题参考代码：</h3>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 200200
#define isdigit(x) ((x) &gt;= &#39;0&#39; &amp;&amp; (x) &lt;= &#39;9&#39;)
inline int read() {
    int res = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (c ^ 48), c = getchar();
    return res;
}
int aa[maxn], cnt[maxn], first[maxn], last[maxn], ans[maxn], belong[maxn], inp[maxn], vis[maxn], ncnt, l = 1, r, now, size, bnum; //莫队相关
int ord[maxn], val[maxn], head[maxn], depth[maxn], fa[maxn][30], ecnt;
int n, m;
struct edge {
    int to, next;
} e[maxn];
void adde(int u, int v) {
    e[++ecnt] = (edge){v, head[u]};
    head[u] = ecnt;
    e[++ecnt] = (edge){u, head[v]};
    head[v] = ecnt;
}
void dfs(int x) {
    ord[++ncnt] = x;
    first[x] = ncnt;
    for(int k = head[x]; k; k = e[k].next) {
        int to = e[k].to;
        if(to == fa[x][0]) continue;
        depth[to] = depth[x] + 1;
        fa[to][0] = x;
        for(int i = 1; (1 &lt;&lt; i) &lt;= depth[to]; ++i) fa[to][i] = fa[fa[to][i - 1]][i - 1];
        dfs(to);
    }
    ord[++ncnt] = x;
    last[x] = ncnt;
}
int getlca(int u, int v) {
    if(depth[u] &lt; depth[v]) swap(u, v);
    for(int i = 20; i + 1; --i) 
        if(depth[u] - (1 &lt;&lt; i) &gt;= depth[v]) u = fa[u][i];
    if(u == v) return u;
    for(int i = 20; i + 1; --i)
        if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
struct query {
    int l, r, lca, id;
} q[maxn];
int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? (belong[a.l] &lt; belong[b.l]) : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);
}
void work(int pos) {
    vis[pos] ? now -= !--cnt[val[pos]] : now += !cnt[val[pos]]++;
    vis[pos] ^= 1;
}
int main() {
    n = read(); m = read();
    for(int i = 1; i &lt;= n; ++i) 
        val[i] = inp[i] = read();
    sort(inp + 1, inp + n + 1);
    int tot = unique(inp + 1, inp + n + 1) - inp - 1;
    for(int i = 1; i &lt;= n; ++i)
        val[i] = lower_bound(inp + 1, inp + tot + 1, val[i]) - inp;
    for(int i = 1; i &lt; n; ++i) adde(read(), read());
    depth[1] = 1;
    dfs(1);
    size = sqrt(ncnt), bnum = ceil((double) ncnt / size);
    for(int i = 1; i &lt;= bnum; ++i)
        for(int j = size * (i - 1) + 1; j &lt;= i * size; ++j) belong[j] = i;
    for(int i = 1; i &lt;= m; ++i) {
        int L = read(), R = read(), lca = getlca(L, R);
        if(first[L] &gt; first[R]) swap(L, R);
        if(L == lca) {
            q[i].l = first[L];
            q[i].r = first[R];
        }
        else {
            q[i].l = last[L];
            q[i].r = first[R];
            q[i].lca = lca;
        }
        q[i].id = i;
    }
    sort(q + 1, q + m + 1, cmp);
    for(int i = 1; i &lt;= m; ++i) {
        int ql = q[i].l, qr = q[i].r, lca = q[i].lca;
        while(l &lt; ql) work(ord[l++]);
        while(l &gt; ql) work(ord[--l]);
        while(r &lt; qr) work(ord[++r]);
        while(r &gt; qr) work(ord[r--]);
        if(lca) work(lca);
        ans[q[i].id] = now;
        if(lca) work(lca);
    }
    for(int i = 1; i &lt;= m; ++i) printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}</code></pre>
<hr />
<h1 id="莫队算法的扩展回滚莫队">6、莫队算法的扩展——回滚莫队</h1>
<p>莫队维护区间统计信息虽然方便，但在某些场合下却非常鸡肋。比如如下这题：</p>
<h3 id="at1219-joi2013歴史の研究"><a href="https://www.luogu.org/problemnew/show/AT1219">AT1219 [JOI2013]歴史の研究</a></h3>
<h4 id="题目描述-3">题目描述</h4>
<p>IOI国历史研究的第一人——JOI教授，最近获得了一份被认为是古代IOI国的住民写下的日记。JOI教授为了通过这份日记来研究古代IOI国的生活，开始着手调查日记中记载的事件。</p>
<p>日记中记录了连续N天发生的时间，大约每天发生一件。</p>
<p>事件有种类之分。第i天<span class="math inline">\((1&lt;=i&lt;=N)\)</span>发生的事件的种类用一个整数<span class="math inline">\(X_i\)</span>表示，<span class="math inline">\(X_i\)</span>越大，事件的规模就越大。</p>
<p>JOI教授决定用如下的方法分析这些日记：</p>
<p><span class="math inline">\(1\)</span>.选择日记中连续的一些天作为分析的时间段</p>
<p><span class="math inline">\(2\)</span>.事件种类t的重要度为t×(这段时间内重要度为t的事件数)</p>
<p><span class="math inline">\(3\)</span>.计算出所有事件种类的重要度，输出其中的最大值</p>
<p>现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值。</p>
<h4 id="输入格式-3">输入格式</h4>
<p>第一行两个空格分隔的整数<span class="math inline">\(N\)</span>和<span class="math inline">\(Q\)</span>，表示日记一共记录了<span class="math inline">\(N\)</span>天，询问有<span class="math inline">\(Q\)</span>次。</p>
<p>接下来一行N个空格分隔的整数<span class="math inline">\(X_1\)</span>...<span class="math inline">\(X_N\)</span>，<span class="math inline">\(X_i\)</span>表示第<span class="math inline">\(i\)</span>天发生的事件的种类</p>
<p>接下来Q行，第i行<span class="math inline">\((1&lt;=i&lt;=Q)\)</span>有两个空格分隔整数<span class="math inline">\(A_i\)</span>和<span class="math inline">\(B_i\)</span>，表示第i次询问的区间为<span class="math inline">\([A_i,B_i]\)</span>。</p>
<h4 id="输入输出样例-3">输入输出样例</h4>
<h4 id="输入样例1-2">输入样例#1：</h4>
<pre><code>5 5
9 8 7 8 9
1 2
3 4
4 4
1 4
2 4</code></pre>
<h4 id="输出样例1-3">输出样例#1：</h4>
<pre><code>9
8
8
16
16</code></pre>
<p>题目到手很快就能想到用莫队维护这个最大值，添加值很好做，直接加个计数器，然后乘一下取个max就完事了。然后删除……不会。想到的唯一办法就是在当前计数器清零后往前枚举，找到一个可行的最大值再替换。这样的复杂度会多一维，达到<span class="math inline">\(O(n^2\sqrt{n})\)</span>，还不如直接n方暴力，<del>说不定就能过百万了呢</del></p>
<p>此时，由于莫队的无敌（雾），有神犇发明了一个<del>玄学</del>高效的算法，复杂度最坏<span class="math inline">\(O(n\sqrt{n})\)</span>，而且常数碾压同为<span class="math inline">\(O(n\sqrt{n})\)</span>的块状数组做法。</p>
<p>我们观察莫队的性质：<strong>左端点在同一块中的所有查询区间右端点单调递增</strong>。这样，对于左端点在同一块中的每个区间，我们都可以<span class="math inline">\(O(n)\)</span>解决所有的右端点，且不用回头删除值（单调递增）。考虑枚举每个块，总共需要枚举<span class="math inline">\(\sqrt{n}\)</span>个块，这部分的总复杂度<span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>又对于每个块内的左端点：假设每个块内的每个左端点都从块右端开始统计，每次都重新开始暴力统计一次，做完每个左端点复杂度<span class="math inline">\(O(\sqrt{n})\)</span>，共<span class="math inline">\(n\)</span>个左端点，总复杂度<span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>我们发现这两部分是很容易结合起来的。做法就是枚举每个块，每次把<span class="math inline">\(l\)</span>、<span class="math inline">\(r\)</span>指针置于块尾+1的位置和块尾（至于为什么+1还请看前面），先暴力处理掉左右端点在一块的特殊情况（<span class="math inline">\(O(\sqrt{n})\)</span>），然后右端点暴力向右推，左端点一个个解决，在移动左指针前纪录一下当前状态，移动保存值后复原即可，也无需删除。以上的问题完美解决。（岂不美滋滋？？#滑稽#）</p>
<p>注意暴力和正常推指针时的<span class="math inline">\(cnt\)</span>不要共用，而且每做一个新块都要把<span class="math inline">\(cnt\)</span>清零。这样回滚莫队代码不难写出啦（难调啊）：</p>
<h3 id="例题参考代码-2">例题参考代码：</h3>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using namespace std;
#define maxn 100100
#define maxb 5050
#define ll long long
int aa[maxn], typ[maxn], cnt[maxn], cnt2[maxn], belong[maxn], lb[maxn], rb[maxn], inp[maxn];
ll ans[maxn];
struct query {
    int l, r, id;
} q[maxn];
int n, m, size, bnum;
#define isdigit(x) ((x) &gt;= &#39;0&#39; &amp;&amp; (x) &lt;= &#39;9&#39;)
inline int read() {
    int res = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (c ^ 48), c = getchar();
    return res;
}
int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : a.r &lt; b.r; 
}
int main() {
    n = read(), m = read();
    size = sqrt(n);
    bnum = ceil((double) n / size);
    for(int i = 1; i &lt;= bnum; ++i) {
        lb[i] = size * (i - 1) + 1;
        rb[i] = size * i;
        for(int j = lb[i]; j &lt;= rb[i]; ++j) belong[j] = i;
    }
    rb[bnum] = n;
    for(int i = 1; i &lt;= n; ++i) inp[i] = aa[i] = read();
    sort(inp + 1, inp + n + 1);
    int tot = unique(inp + 1, inp + n + 1) - inp - 1;
    for(int i = 1; i &lt;= n; ++i) typ[i] = lower_bound(inp + 1, inp + tot + 1, aa[i]) - inp;
    for(int i = 1; i &lt;= m; ++i) {
        q[i].l = read(), q[i].r = read();
        q[i].id = i;
    }
    sort(q + 1, q + m + 1, cmp);
    int i = 1;
    for(int k = 0; k &lt;= bnum; ++k) {
        int l = rb[k] + 1, r = rb[k];
        ll now = 0;
        memset(cnt, 0, sizeof(cnt));
        for( ; belong[q[i].l] == k; ++i) {
            int ql = q[i].l, qr = q[i].r;
            ll tmp;
            if(belong[ql] == belong[qr]) {
                tmp = 0;
                for(int j = ql; j &lt;= qr; ++j) cnt2[typ[j]] = 0;
                for(int j = ql; j &lt;= qr; ++j) {
                    ++cnt2[typ[j]]; tmp = max(tmp, 1ll * cnt2[typ[j]] * aa[j]);
                }
                ans[q[i].id] = tmp;
                continue;
            }
            while(r &lt; qr) {
                ++r; ++cnt[typ[r]]; now = max(now, 1ll * cnt[typ[r]] * aa[r]);
            }
            tmp = now;
            while(l &gt; ql){
                --l; ++cnt[typ[l]]; now = max(now, 1ll * cnt[typ[l]] * aa[l]);
            } 
            ans[q[i].id] = now;
            while(l &lt; rb[k] + 1) {
                --cnt[typ[l]];
                l++;
            }
            now = tmp;
        }
    }
    for(int i = 1; i &lt;= m; ++i) printf(&quot;%lld\n&quot;, ans[i]);
    return 0;
}</code></pre>
<p>注意这里分块时有个坑点：向上取整的<code>ceil</code>不要写成<code>floor</code>，这样在普通莫队中会多出一个块0，完全不影响AC，但在回滚莫队中就是WA，WA到我浑身不得劲qwq</p>
<h3 id="回滚莫队完结撒花ヽノqwq">回滚莫队完结撒花✿✿ヽ(°▽°)ノ✿qwq</h3>
<hr />
<h1 id="练习题">7、练习题</h1>
<p>这里放的主要是莫队裸题，没有与其他算法的综合应用，但部分有思维难度。如需要综合应用题请左转<a href="https://www.luogu.org/problemnew/lists?name=&amp;orderitem=pid&amp;tag=41&amp;content=0&amp;type=">【Luogu OJ】</a> 右转<a href="https://www.lydsy.com/JudgeOnline/problemset.php">【BZOJ】</a></p>
<p>虽然莫队算法思想很简单，但与它有关的应用还是很经(du)典(liu)的。下面是一些经(du)典(liu)的例题：</p>
<h3 id="基础题luogu-p2709-小b的询问">1、<a href="https://www.luogu.org/problemnew/show/P2709">【基础题】Luogu P2709 小B的询问</a></h3>
<p>这题的话，手推公式很容易就能做出来，而且题目无坑点，甚至无需卡常</p>
<p>代码不给了qwq，和例题差不了两句话qwq</p>
<h3 id="进阶题luogu-p1494-国家集训队小z的袜子">2、<a href="https://www.luogu.org/problemnew/show/P1494">【进阶题】Luogu P1494 [国家集训队]小Z的袜子</a></h3>
<p>这题需要一些基础但较为复杂的数学演算，打表基本不靠谱（另外还要注意约分）</p>
<p>留给大家自行推理（代码还是很简单哒qwq）</p>
<h3 id="进阶题luogu-p3709-大爷的字符串题">3、<a href="https://www.luogu.org/problemnew/show/P3709">【进阶题】Luogu P3709 大爷的字符串题</a></h3>
<p>内个，题意别看了，题目要求的是区间众数的出现次数（出题人语文不好）（当然你也可以直接把题意推出来qwq）</p>
<p>即便题意明了了，这题还是有点综合性的（区间众数这东西并不好求）</p>
<p>真是一道好(du)题(liu)（逃</p>
<h3 id="最终挑战luogu-p4074-wc2013糖果公园">4、<a href="https://www.luogu.org/problemnew/show/P4074">【最终挑战】Luogu P4074 [WC2013]糖果公园</a></h3>
<p>承诺的黑题终于来啦，撒花✿✿ヽ(°▽°)ノ✿</p>
<p>然而这题并不难，树上带修莫队模板题，相信你很快就能切掉它qwq</p>
<h4 id="参考代码-1">参考代码：</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 200200
#define ll long long
int cnt[maxn], aa[maxn], belong[maxn], inp[maxn], n, m, Q, ncnt, size, bnum, w[maxn], v[maxn], ccnt, qcnt;
int val[maxn], fa[maxn][30], depth[maxn], head[maxn], ecnt;
int fir[maxn], la[maxn], vis[maxn];
int l = 1, r = 0, t = 0;
ll now, ans[maxn];
struct edge {
    int to, next;
} e[maxn];
void adde(int u, int v) {
    e[++ecnt] = (edge){v, head[u]};
    head[u] = ecnt;
    e[++ecnt] = (edge){u, head[v]};
    head[v] = ecnt;
}
void dfs(int x) {
    aa[++ncnt] = x;
    fir[x] = ncnt;
    for(int k = head[x]; k; k = e[k].next) {
        int to = e[k].to;
        if(depth[to]) continue;
        depth[to] = depth[x] + 1;
        fa[to][0] = x;
        for(int i = 1; (1 &lt;&lt; i) &lt;= depth[to]; ++i) fa[to][i] = fa[fa[to][i - 1]][i - 1];
        dfs(to);
    }
    aa[++ncnt] = x;
    la[x] = ncnt;
}
int getlca(int u, int v) {
    if(depth[u] &lt; depth[v]) swap(u, v);
    for(int i = 20; i + 1; --i) if(depth[fa[u][i]] &gt;= depth[v]) u = fa[u][i];
    if(u == v) return u;
    for(int i = 20; i + 1; --i) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
struct query {
    int l, r, id, lca, t;
} q[maxn];
int cmp(query a, query b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.r] ^ belong[b.r]) ? belong[a.r] &lt; belong[b.r] : a.t &lt; b.t );
}
inline void add(int pos) {
    now += 1ll * v[val[pos]] * w[++cnt[val[pos]]];
}
inline void del(int pos) {
    now -= 1ll * v[val[pos]] * w[cnt[val[pos]]--];
}
inline void work(int pos) {
    vis[pos] ? del(pos) : add(pos);
    vis[pos] ^= 1;
}
struct change {
    int pos, val;
} ch[maxn];
void modify(int x) {
    if(vis[ch[x].pos]) {
        work(ch[x].pos);
        swap(val[ch[x].pos], ch[x].val);
        work(ch[x].pos);
    }
    else swap(val[ch[x].pos], ch[x].val);
}
#define isdigit(x) ((x) &gt;= &#39;0&#39; &amp;&amp; (x) &lt;= &#39;9&#39;)
inline int read() {
    int res = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (c ^ 48), c = getchar();
    return res;
}
int main() {
    n = read(), m = read(), Q = read();
    for(int i = 1; i &lt;= m; ++i) v[i] = read();
    for(int i = 1; i &lt;= n; ++i) w[i] = read();
    for(int i = 1; i &lt; n; ++i) {
        int u = read(), v = read();
        adde(u, v);
    }
    for(int i = 1; i &lt;= n; ++i) val[i] = read();
    depth[1] = 1;
    dfs(1);
    size = pow(ncnt, 2.0 / 3.0);
    bnum = ceil((double)ncnt / size);
    for(int i = 1; i &lt;= bnum; ++i)
        for(int j = size * (i - 1) + 1; j &lt;= i * size; ++j) belong[j] = i;
    for(int i = 1; i &lt;= Q; ++i) {
        int opt = read(), a = read(), b = read();
        if(opt) {
            int lca = getlca(a, b);
            q[++qcnt].t = ccnt;
            q[qcnt].id = qcnt;
            if(fir[a] &gt; fir[b]) swap(a, b);
            if(a == lca) q[qcnt].l = fir[a], q[qcnt].r = fir[b];
            else q[qcnt].l = la[a], q[qcnt].r = fir[b], q[qcnt].lca = lca;
        }
        else {
            ch[++ccnt].pos = a;
            ch[ccnt].val = b;
        }
    }
    sort(q + 1, q + qcnt + 1, cmp);
    for(int i = 1; i &lt;= qcnt; ++i) {
        int ql = q[i].l, qr = q[i].r, qt = q[i].t, qlca = q[i].lca;
        while(l &lt; ql) work(aa[l++]);
        while(l &gt; ql) work(aa[--l]);
        while(r &lt; qr) work(aa[++r]);
        while(r &gt; qr) work(aa[r--]);
        while(t &lt; qt) modify(++t);
        while(t &gt; qt) modify(t--);
        if(qlca) work(qlca);
        ans[q[i].id] = now;
        if(qlca) work(qlca);
    }
    for(int i = 1; i &lt;= qcnt; ++i) printf(&quot;%lld\n&quot;, ans[i]);
    return 0;
}</code></pre>
<h3 id="其它">5、其它</h3>
<p>自己找qwq，百度是个很好的东西qwq</p>
<hr />
<h1 id="尾声">尾声</h1>
<p>耗时将近两天的长篇大论终于要结束啦，再来无耻的求一波赞qwq（逃</p>
<p>感谢各位坚持着看过来（雾）的dalao，文章如有错误欢迎指出哦qwq</p>
<h2 id="noip-2019-rp">NOIP 2019 RP++</h2>


