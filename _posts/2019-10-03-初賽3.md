---
layout: post
title: 對於樹上倍增LCA的復習
date: 2019-10-02
categories: blog
tags: []
description: 
---

最近題目綫段樹用的很多。（我也不知道爲甚麽。。。。）

所以我今天要復習下綫段樹了！


<p><span class="bjh-p">一、简介线段树<span class="bjh-br"></span></span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">ps: _此处以询问区间和为例。实际上线段树可以处理很多<span class="bjh-strong">符合结合律</span>的操作。（比如说加法，a[1]+a[2]+a[3]+a[4]=(a[1]+a[2])+(a[3]+a[4])）</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">线段树之所以称为“树”，是因为其具有树的结构特性。线段树由于本身是专门用来处理区间问题的（包括RMQ、RSQ问题等。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><div class="img-container"><img class="normal" width="461px" data-loadfunc=0 src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3307176070,3760001161&amp;fm=173&amp;app=25&amp;f=JPEG?w=461&amp;h=240&amp;s=00324C32853A642142F1ECD1020030B2" data-loaded=0 /></div><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">图片来源于互联网。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">对于每一个子节点而言，都表示整个序列中的一段子区间；对于每个叶子节点而言，都表示序列中的单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息则是他的每一个子节点信息的整合。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">有没有觉得很熟悉？对，<span class="bjh-strong">线段树就是分块思想的树化，或者说是对于信息处理的二进制化</span>——用于达到O(logn)级别的处理速度，log以2为底。（其实以几为底都只不过是个常数，可忽略)。而分块的思想，则是可以用一句话总结为：<span class="bjh-strong">通过将整个序列分为有穷个小块，对于要查询的一段区间，总是可以整合成k个所分块与m个单个元素的信息的并</span>(0≤k,m≤sqrt{n})。但普通的分块不能高效率地解决很多问题，所以作为log级别的数据结构，线段树应运而生。</span></p><p><span class="bjh-hr"></span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">Extra  Tips</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">其实，虽然线段树的时间效率要高于分块但是实际上分块的总合并次数不会超过sqrt{n}但是线段树在最坏情况下的合并次数显然是要大于这个时间效率的qwq。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">~~但是毕竟也只是一个很大的常数而已~~</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">However,虽说如此，分块的应用范围还是要广于线段树的，因为虽然线段树好像很快，但是它只能维护带有结合律的信息，比如区间max/min、sum、xor之类的，但是不带有结合律的信息就不能维护（且看下文分解）；而分块则灵活得多，可以维护很多别的东西,因为实际上分块的本质就是<span class="bjh-strong">优雅的暴力</span>qwq。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">其实越暴力的算法可以支持的操作就越多、功能性就越强呐！~~你看n^2的暴力几乎什么都可以维护~~</span></p><p><span class="bjh-hr"></span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">二、逐步分析线段树的构造实现</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">1、建树与维护</span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p">由于二叉树的自身特性，对于每个父亲节点的编号i,他的两个儿子的编号分别是2i和2i+1，所以我们考虑写两个O(1)的取儿子函数：</span></p><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=662819164,1650549400&amp;fm=173&amp;app=25&amp;f=JPEG?w=639&amp;h=122&amp;s=8DAA753249234B201EF5D1DA000050B2" data-loaded=0 /></div><p><span class="bjh-p">_</span></p><p><span class="bjh-p">Extra  Tips</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">1、此处的inline可以有效防止无需入栈的信息入栈，节省时间和空间。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">2、二进制位左移一位代表着数值*2，而如果左移完之后再或上1，由于左移完之后最后一位二进制位上一定会是0，所以|1等价于+1。</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">~~用二进制运算不是为了装X,相信我，会快的！~~</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">那么根据线段树的服务对象，可以得到线段树的维护:</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1580688807,1232241859&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=158&amp;s=0750E5334B634F2018F5A5DA000080B2" data-loaded=0 /></div><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">此处一定要注意，push up操作的目的是为了<span class="bjh-strong">维护父子节点之间的逻辑关系</span>。当我们递归建树时，对于每一个节点我们都需要遍历一遍，并且电脑中的<span class="bjh-strong">递归实际意义是先向底层递归，然后从底层向上回溯</span>，所以开始递归之后必然是<span class="bjh-strong">先去整合子节点的信息</span>，再向它们的祖先回溯整合之后的信息。(这其实是正确性的证明啦)</span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p">呐，我们在这儿就能看出来，实际上push_up是在合并两个子节点的信息，所以需要信息满足结合律！</span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p">那么对于建树，由于二叉树自身的父子节点之间的可传递关系，所以可以考虑递归建树（emmmm之前好像不小心剧透了qwq），并且在建树的同时，我们应该维护父子节点的关系：</span></p><p><span class="bjh-p"></span></p><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3677253522,4082723007&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=193&amp;s=055065330F624D204AF501DB000080B2" data-loaded=0 /></div><p><span class="bjh-p"></span></p><p><span class="bjh-p">2、接下来谈区间修改</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">为什么不讨论单点修改呢qwq?因为其实很显然，单点修改就是区间修改的一个子问题而已，即区间长度为1时进行的区间修改操作罢了qwq</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">那么对于区间操作，我们考虑引入一个名叫“lazy tag”（懒标记）的东西——之所以称其“lazy”，是因为原本区间修改需要通过先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达O(nlogn)的级别。但当我们引入了懒标记之后，区间更新的期望复杂度就降到了O(logn)的级别且甚至会更低.</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">（1）首先先来从分块思想上解释如何区间修改：<span class="bjh-br"></span></span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">分块的思想是<span class="bjh-strong">通过将整个序列分为有穷个小块，对于要查询的一段区间，总是可以整合成k个所分块与m个单个元素的信息的并(0&lt;=k,m&lt;=logn)</span>(小小修改了一下的上面的前言qwq)</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">那么我们可以反过来思考这个问题：对于一个要修改的、长度为l的区间来说，总是可以看做由一个长度为2 ^ logn 和剩下的元素（或者小区间组成）。那么我们就可以先将其拆分成线段树上节点所示的区间，之后分开处理：</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p"><span class="bjh-strong">如果单个元素被包含就只改变自己，如果整个区间被包含就修改整个区间</span></span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p">其实好像这个在分块里不是特别简单地实现，但是在线段树里，无论是元素还是区间都是线段树上的一个节点，<span class="bjh-strong">所以我们不需要区分区间还是元素</span>，加个判断就好。</span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p">（2）懒标记的正确打开方式</span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p">首先，懒标记的作用是记录每次、每个节点要更新的值，也就是delta,但线段树的优点不在于全记录（全记录依然很慢qwq），而在于传递式记录：</span></p><p><span class="bjh-p"></span></p><p><span class="bjh-p"><span class="bjh-strong">整个区间都被操作，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果四环以内只修改了自己的话，那就只改变自己。</span></span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">毕竟，如果我们采用上述的优化方式的话，我们就需要在每次区间的查询修改时pushdown一次，以免重复或者冲突或者爆炸qwq</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">那么对于pushdown而言，其实就是纯粹的pushup的逆向思维(但不是逆向操作)：</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">因为修改信息存在父节点上，所以要由父节点向下传导lazy tag</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">那么问题来了：怎么传导pushdown呢？这里很有意思，开始回溯时执行pushup,因为是向上传导信息；那我们如果要让它向下更新，就调整顺序，在向下递归的时候pushdown不就好惹~qwq：</span></p><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=438560588,1176869395&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=627&amp;s=85706D33C90E664D56D580DA0000C0B2" data-loaded=0 /></div><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">对于复杂度而言，由于完全二叉树的深度不超过logn，那么单点修改显然是O(logn)的，区间修改的话，由于我们的这个区间至多分logn个子区间，对于每个子区间的查询是O(1)的，所以复杂度自然是O(logn)~~不过带一点常数~~</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">3、那么对于区间查询</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">没什么好说的，由于是信息的整合，所以还是要用到分块思想，我实在是不想再码一遍了qwq</span></p><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3398241274,3130704354&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=202&amp;s=85D065320B6249200AFDE9DA0000C0B2" data-loaded=0 /></div><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">最后贴~~高清无码的~~标程：</span></p><p><span class="bjh-p"><span class="bjh-br"></span></span></p><p><span class="bjh-p">（还有，输入大数据一定不要用不加优化的cin/cout啊）</span></p><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2423100404,4177251640&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=1047&amp;s=04526532090B404D585DA1DA0000C0B3" data-loaded=0 /></div><div class="img-container"><img class="large" data-loadfunc=0 src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3784600897,2749988656&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=605&amp;s=05726532C91A424D507DA1DA000010B2" data-loaded=0 /></div><p><span class="bjh-hr"></span></p><p>
